{"version":3,"sources":["../src/ui.ts"],"names":[],"mappings":";AACA,SAAS,gBAAgB;AACzB,SAAS,QAAQ,gBAAgB,mBAAmB;AAEpD,SAAS,OAAO,kBAAkB;AAElC,IAAM,oBAAoB,CAAC,UAAU,SAAS;AAQ9C,SAAS,iBAAiB,MAAc;AACtC,QAAM,SAAS,MAAM,MAAM,EAAE,KAAK,MAAM,CAAC;AACzC,QAAM,QAA0C,CAAC;AAGjD,aAAW,QAAQ,CAAC,UAAU;AAC5B,QAAI,MAAM,SAAS,QAAQ;AACzB,YAAM,KAAK,KAAK;AAAA,IAClB;AAAA,EACF,CAAC;AAED,SAAO,MAAM,IAAI,CAAC,SAAS,MAAM,IAAI,EAAE,OAAO,OAAO;AACvD;AAUO,SAAS,kBACd,MACA,kBACA;AACA,QAAM,QAAQ,iBAAiB,IAAI;AAEnC,aAAW,QAAQ,OAAO;AACxB,QAAI;AACF,YAAM,MAAM,IAAI,IAAI,IAAI;AACxB;AAAA,QACE,kBAAkB,SAAS,IAAI,QAAQ;AAAA,QACvC,4BAA4B,kBAAkB,KAAK,IAAI,CAAC;AAAA,MAC1D;AAEA,YAAM,WACJ,IAAI,aAAa,YAAY,IAAI,SAAS,MAAM,GAAG,EAAE,CAAC,IAAI,IAAI;AAEhE,aAAO,CAAC,iBAAiB,QAAQ,GAAG,mCAAmC;AAAA,IACzE,SAAS,OAAO;AACd,YAAM,IAAI;AAAA,QACR,gBACE,iBAAiB,iBACb,MAAM,UACN,sBACN;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAWO,SAAS,uBACd,WACA,kBACA;AACA,QAAM,EAAE,KAAK,IAAI;AACjB,UAAQ,MAAM;AAAA,IACZ,KAAK,SAAS;AACZ,gBAAU,SAAS;AAAA,QAAQ,CAAC,SAC1B,uBAAuB,MAAM,gBAAgB;AAAA,MAC/C;AACA;AAAA,IACF,KAAK,SAAS;AACZ,6BAAuB,UAAU,OAAO,gBAAgB;AACxD;AAAA,IACF,KAAK,SAAS;AACZ,wBAAkB,UAAU,OAAO,gBAAgB;AACnD;AAAA,IACF;AACE;AAAA,EACJ;AACF;AAQO,SAAS,mBAAmB,WAA8B;AAC/D,QAAM,EAAE,KAAK,IAAI;AAEjB,UAAQ,MAAM;AAAA,IACZ,KAAK,SAAS;AACZ,aAAO,UAAU,SAAS;AAAA;AAAA;AAAA,QAGxB,CAAC,KAAK,SAAS,MAAM,mBAAmB,IAAI;AAAA,QAC5C;AAAA,MACF;AAAA,IACF,KAAK,SAAS;AACZ,aAAO,mBAAmB,UAAU,KAAK;AAAA,IAC3C,KAAK,SAAS;AACZ,aAAO,UAAU,MAAM;AAAA,IACzB;AACE,aAAO;AAAA,EACX;AACF;AAQO,SAAS,YACd,WAC+B;AAC/B,SAAO,YAAY,WAAW,UAAU;AAC1C","sourcesContent":["import type { Component, NodeWithChildren } from '@metamask/snaps-sdk';\nimport { NodeType } from '@metamask/snaps-sdk';\nimport { assert, AssertionError, hasProperty } from '@metamask/utils';\nimport type { Tokens } from 'marked';\nimport { lexer, walkTokens } from 'marked';\n\nconst ALLOWED_PROTOCOLS = ['https:', 'mailto:'];\n\n/**\n * Extract all links from a Markdown text string using the `marked` lexer.\n *\n * @param text - The markdown text string.\n * @returns A list of URLs linked to in the string.\n */\nfunction getMarkdownLinks(text: string) {\n  const tokens = lexer(text, { gfm: false });\n  const links: (Tokens.Link | Tokens.Generic)[] = [];\n\n  // Walk the lexed tokens and collect all link tokens\n  walkTokens(tokens, (token) => {\n    if (token.type === 'link') {\n      links.push(token);\n    }\n  });\n\n  return links.map((link) => link?.href).filter(Boolean);\n}\n\n/**\n * Searches for markdown links in a string and checks them against the phishing list.\n *\n * @param text - The text to verify.\n * @param isOnPhishingList - The function that checks the link against the\n * phishing list.\n * @throws If the text contains a link that is not allowed.\n */\nexport function validateTextLinks(\n  text: string,\n  isOnPhishingList: (url: string) => boolean,\n) {\n  const links = getMarkdownLinks(text);\n\n  for (const link of links) {\n    try {\n      const url = new URL(link);\n      assert(\n        ALLOWED_PROTOCOLS.includes(url.protocol),\n        `Protocol must be one of: ${ALLOWED_PROTOCOLS.join(', ')}.`,\n      );\n\n      const hostname =\n        url.protocol === 'mailto:' ? url.pathname.split('@')[1] : url.hostname;\n\n      assert(!isOnPhishingList(hostname), 'The specified URL is not allowed.');\n    } catch (error) {\n      throw new Error(\n        `Invalid URL: ${\n          error instanceof AssertionError\n            ? error.message\n            : 'Unable to parse URL.'\n        }`,\n      );\n    }\n  }\n}\n\n/**\n * Search for links in UI components and check that the URL they are trying to\n * pass in is not in the phishing list.\n *\n * @param component - The custom UI component.\n * @param isOnPhishingList - The function that checks the link against the\n * phishing list.\n * @throws If the component contains a link that is not allowed.\n */\nexport function validateComponentLinks(\n  component: Component,\n  isOnPhishingList: (url: string) => boolean,\n) {\n  const { type } = component;\n  switch (type) {\n    case NodeType.Panel:\n      component.children.forEach((node) =>\n        validateComponentLinks(node, isOnPhishingList),\n      );\n      break;\n    case NodeType.Row:\n      validateComponentLinks(component.value, isOnPhishingList);\n      break;\n    case NodeType.Text:\n      validateTextLinks(component.value, isOnPhishingList);\n      break;\n    default:\n      break;\n  }\n}\n\n/**\n * Calculate the total length of all text in the component.\n *\n * @param component - A custom UI component.\n * @returns The total length of all text components in the component.\n */\nexport function getTotalTextLength(component: Component): number {\n  const { type } = component;\n\n  switch (type) {\n    case NodeType.Panel:\n      return component.children.reduce<number>(\n        // This is a bug in TypeScript: https://github.com/microsoft/TypeScript/issues/48313\n        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n        (sum, node) => sum + getTotalTextLength(node),\n        0,\n      );\n    case NodeType.Row:\n      return getTotalTextLength(component.value);\n    case NodeType.Text:\n      return component.value.length;\n    default:\n      return 0;\n  }\n}\n\n/**\n * Check if a component has children.\n *\n * @param component - A custom UI component.\n * @returns `true` if the component has children, `false` otherwise.\n */\nexport function hasChildren(\n  component: Component,\n): component is NodeWithChildren {\n  return hasProperty(component, 'children');\n}\n"]}