{"version":3,"sources":["../src/common/BaseSnapExecutor.ts"],"sourcesContent":["// eslint-disable-next-line @typescript-eslint/triple-slash-reference, spaced-comment\n/// <reference path=\"../../../../node_modules/ses/types.d.ts\" />\nimport { createIdRemapMiddleware } from '@metamask/json-rpc-engine';\nimport type { RequestArguments } from '@metamask/providers';\nimport { StreamProvider } from '@metamask/providers/dist/StreamProvider';\nimport { errorCodes, rpcErrors, serializeError } from '@metamask/rpc-errors';\nimport type { SnapsProvider } from '@metamask/snaps-sdk';\nimport { getErrorData } from '@metamask/snaps-sdk';\nimport type {\n  SnapExports,\n  HandlerType,\n  SnapExportsParameters,\n} from '@metamask/snaps-utils';\nimport {\n  SNAP_EXPORT_NAMES,\n  logError,\n  SNAP_EXPORTS,\n  WrappedSnapError,\n  unwrapError,\n  logInfo,\n} from '@metamask/snaps-utils';\nimport type {\n  JsonRpcNotification,\n  JsonRpcId,\n  JsonRpcRequest,\n  Json,\n} from '@metamask/utils';\nimport {\n  assert,\n  isJsonRpcRequest,\n  hasProperty,\n  getSafeJson,\n  JsonRpcIdStruct,\n} from '@metamask/utils';\nimport type { Duplex } from 'readable-stream';\nimport { validate, is } from 'superstruct';\n\nimport { log } from '../logging';\nimport type { CommandMethodsMapping } from './commands';\nimport { getCommandMethodImplementations } from './commands';\nimport { createEndowments } from './endowments';\nimport { addEventListener, removeEventListener } from './globalEvents';\nimport { sortParamKeys } from './sortParams';\nimport {\n  assertEthereumOutboundRequest,\n  assertSnapOutboundRequest,\n  sanitizeRequestArguments,\n  proxyStreamProvider,\n  withTeardown,\n  isValidResponse,\n} from './utils';\nimport {\n  ExecuteSnapRequestArgumentsStruct,\n  PingRequestArgumentsStruct,\n  SnapRpcRequestArgumentsStruct,\n  TerminateRequestArgumentsStruct,\n} from './validation';\n\ntype EvaluationData = {\n  stop: () => void;\n};\n\ntype SnapData = {\n  exports: SnapExports;\n  runningEvaluations: Set<EvaluationData>;\n  idleTeardown: () => Promise<void>;\n};\n\nconst fallbackError = {\n  code: errorCodes.rpc.internal,\n  message: 'Execution Environment Error',\n};\n\nconst unhandledError = rpcErrors\n  .internal<Json>({\n    message: 'Unhandled Snap Error',\n  })\n  .serialize();\n\nexport type InvokeSnapArgs = Omit<SnapExportsParameters[0], 'chainId'>;\n\nexport type InvokeSnap = (\n  target: string,\n  handler: HandlerType,\n  args: InvokeSnapArgs | undefined,\n) => Promise<Json>;\n\n/**\n * The supported methods in the execution environment. The validator checks the\n * incoming JSON-RPC request, and the `params` property is used for sorting the\n * parameters, if they are an object.\n */\nconst EXECUTION_ENVIRONMENT_METHODS = {\n  ping: {\n    struct: PingRequestArgumentsStruct,\n    params: [],\n  },\n  executeSnap: {\n    struct: ExecuteSnapRequestArgumentsStruct,\n    params: ['snapId', 'sourceCode', 'endowments'],\n  },\n  terminate: {\n    struct: TerminateRequestArgumentsStruct,\n    params: [],\n  },\n  snapRpc: {\n    struct: SnapRpcRequestArgumentsStruct,\n    params: ['target', 'handler', 'origin', 'request'],\n  },\n};\n\ntype Methods = typeof EXECUTION_ENVIRONMENT_METHODS;\n\nexport type NotifyFunction = (\n  notification: Omit<JsonRpcNotification, 'jsonrpc'>,\n) => Promise<void>;\n\nexport class BaseSnapExecutor {\n  private readonly snapData: Map<string, SnapData>;\n\n  private readonly commandStream: Duplex;\n\n  private readonly rpcStream: Duplex;\n\n  private readonly methods: CommandMethodsMapping;\n\n  private snapErrorHandler?: (event: ErrorEvent) => void;\n\n  private snapPromiseErrorHandler?: (event: PromiseRejectionEvent) => void;\n\n  private lastTeardown = 0;\n\n  protected constructor(commandStream: Duplex, rpcStream: Duplex) {\n    this.snapData = new Map();\n    this.commandStream = commandStream;\n    this.commandStream.on('data', (data) => {\n      this.onCommandRequest(data).catch((error) => {\n        // TODO: Decide how to handle errors.\n        logError(error);\n      });\n    });\n    this.rpcStream = rpcStream;\n\n    this.methods = getCommandMethodImplementations(\n      this.startSnap.bind(this),\n      async (target, handlerType, args) => {\n        const data = this.snapData.get(target);\n        // We're capturing the handler in case someone modifies the data object\n        // before the call.\n        const handler = data?.exports[handlerType];\n        const { required } = SNAP_EXPORTS[handlerType];\n\n        assert(\n          !required || handler !== undefined,\n          `No ${handlerType} handler exported for snap \"${target}`,\n          rpcErrors.methodNotSupported,\n        );\n\n        // Certain handlers are not required. If they are not exported, we\n        // return null.\n        if (!handler) {\n          return null;\n        }\n\n        let result = await this.executeInSnapContext(target, () =>\n          // TODO: fix handler args type cast\n          handler(args as any),\n        );\n\n        // The handler might not return anything, but undefined is not valid JSON.\n        if (result === undefined) {\n          result = null;\n        }\n\n        // /!\\ Always return only sanitized JSON to prevent security flaws. /!\\\n        try {\n          return getSafeJson(result);\n        } catch (error) {\n          throw rpcErrors.internal(\n            `Received non-JSON-serializable value: ${error.message.replace(\n              /^Assertion failed: /u,\n              '',\n            )}`,\n          );\n        }\n      },\n      this.onTerminate.bind(this),\n    );\n  }\n\n  private errorHandler(error: unknown, data: Record<string, Json>) {\n    const serializedError = serializeError(error, {\n      fallbackError: unhandledError,\n      shouldIncludeStack: false,\n    });\n\n    const errorData = getErrorData(serializedError);\n\n    this.#notify({\n      method: 'UnhandledError',\n      params: {\n        error: {\n          ...serializedError,\n          data: {\n            ...errorData,\n            ...data,\n          },\n        },\n      },\n    }).catch((notifyError) => {\n      logError(notifyError);\n    });\n  }\n\n  private async onCommandRequest(message: JsonRpcRequest) {\n    if (!isJsonRpcRequest(message)) {\n      if (\n        hasProperty(message, 'id') &&\n        is((message as Pick<JsonRpcRequest, 'id'>).id, JsonRpcIdStruct)\n      ) {\n        // Instead of throwing, we directly respond with an error.\n        // We can only do this if the message ID is still valid.\n        await this.#write({\n          error: serializeError(\n            rpcErrors.internal(\n              'JSON-RPC requests must be JSON serializable objects.',\n            ),\n          ),\n          id: (message as Pick<JsonRpcRequest, 'id'>).id,\n          jsonrpc: '2.0',\n        });\n      } else {\n        logInfo(\n          'Command stream received a non-JSON-RPC request, and was unable to respond.',\n        );\n      }\n      return;\n    }\n\n    const { id, method, params } = message;\n\n    if (!hasProperty(EXECUTION_ENVIRONMENT_METHODS, method)) {\n      await this.#respond(id, {\n        error: rpcErrors\n          .methodNotFound({\n            data: {\n              method,\n            },\n          })\n          .serialize(),\n      });\n      return;\n    }\n\n    const methodObject = EXECUTION_ENVIRONMENT_METHODS[method as keyof Methods];\n\n    // support params by-name and by-position\n    const paramsAsArray = sortParamKeys(methodObject.params, params);\n\n    const [error] = validate<any, any>(paramsAsArray, methodObject.struct);\n    if (error) {\n      await this.#respond(id, {\n        error: rpcErrors\n          .invalidParams({\n            message: `Invalid parameters for method \"${method}\": ${error.message}.`,\n            data: {\n              method,\n              params: paramsAsArray,\n            },\n          })\n          .serialize(),\n      });\n      return;\n    }\n\n    try {\n      const result = await (this.methods as any)[method](...paramsAsArray);\n      await this.#respond(id, { result });\n    } catch (rpcError) {\n      await this.#respond(id, {\n        error: serializeError(rpcError, {\n          fallbackError,\n        }),\n      });\n    }\n  }\n\n  // Awaitable function that writes back to the command stream\n  // To prevent snap execution from blocking writing we wrap in a promise\n  // and await it before continuing execution\n  async #write(chunk: Json) {\n    return new Promise<void>((resolve, reject) => {\n      this.commandStream.write(chunk, (error) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n        resolve();\n      });\n    });\n  }\n\n  async #notify(notification: Omit<JsonRpcNotification, 'jsonrpc'>) {\n    if (!isValidResponse(notification)) {\n      throw rpcErrors.internal(\n        'JSON-RPC notifications must be JSON serializable objects smaller than 64 MB.',\n      );\n    }\n\n    await this.#write({\n      ...notification,\n      jsonrpc: '2.0',\n    });\n  }\n\n  async #respond(id: JsonRpcId, response: Record<string, unknown>) {\n    if (!isValidResponse(response)) {\n      // Instead of throwing, we directly respond with an error.\n      // This prevents an issue where we wouldn't respond when errors were non-serializable\n      await this.#write({\n        error: serializeError(\n          rpcErrors.internal(\n            'JSON-RPC responses must be JSON serializable objects smaller than 64 MB.',\n          ),\n        ),\n        id,\n        jsonrpc: '2.0',\n      });\n      return;\n    }\n\n    await this.#write({\n      ...response,\n      id,\n      jsonrpc: '2.0',\n    });\n  }\n\n  /**\n   * Attempts to evaluate a snap in SES. Generates APIs for the snap. May throw\n   * on errors.\n   *\n   * @param snapId - The id of the snap.\n   * @param sourceCode - The source code of the snap, in IIFE format.\n   * @param _endowments - An array of the names of the endowments.\n   */\n  protected async startSnap(\n    snapId: string,\n    sourceCode: string,\n    _endowments: string[],\n  ): Promise<void> {\n    log(`Starting snap '${snapId}' in worker.`);\n    if (this.snapPromiseErrorHandler) {\n      removeEventListener('unhandledrejection', this.snapPromiseErrorHandler);\n    }\n\n    if (this.snapErrorHandler) {\n      removeEventListener('error', this.snapErrorHandler);\n    }\n\n    this.snapErrorHandler = (error: ErrorEvent) => {\n      this.errorHandler(error.error, { snapId });\n    };\n\n    this.snapPromiseErrorHandler = (error: PromiseRejectionEvent) => {\n      this.errorHandler(error instanceof Error ? error : error.reason, {\n        snapId,\n      });\n    };\n\n    const provider = new StreamProvider(this.rpcStream, {\n      jsonRpcStreamName: 'metamask-provider',\n      rpcMiddleware: [createIdRemapMiddleware()],\n    });\n\n    await provider.initialize();\n\n    const snap = this.createSnapGlobal(provider);\n    const ethereum = this.createEIP1193Provider(provider);\n    // We specifically use any type because the Snap can modify the object any way they want\n    const snapModule: any = { exports: {} };\n\n    try {\n      const { endowments, teardown: endowmentTeardown } = createEndowments({\n        snap,\n        ethereum,\n        snapId,\n        endowments: _endowments,\n        notify: this.#notify.bind(this),\n      });\n\n      // !!! Ensure that this is the only place the data is being set.\n      // Other methods access the object value and mutate its properties.\n      this.snapData.set(snapId, {\n        idleTeardown: endowmentTeardown,\n        runningEvaluations: new Set(),\n        exports: {},\n      });\n\n      addEventListener('unhandledRejection', this.snapPromiseErrorHandler);\n      addEventListener('error', this.snapErrorHandler);\n\n      const compartment = new Compartment({\n        ...endowments,\n        module: snapModule,\n        exports: snapModule.exports,\n      });\n\n      // All of those are JavaScript runtime specific and self referential,\n      // but we add them for compatibility sake with external libraries.\n      //\n      // We can't do that in the injected globals object above\n      // because SES creates its own globalThis\n      compartment.globalThis.self = compartment.globalThis;\n      compartment.globalThis.global = compartment.globalThis;\n      compartment.globalThis.window = compartment.globalThis;\n\n      await this.executeInSnapContext(snapId, () => {\n        compartment.evaluate(sourceCode);\n        this.registerSnapExports(snapId, snapModule);\n      });\n    } catch (error) {\n      this.removeSnap(snapId);\n\n      const [cause] = unwrapError(error);\n      throw rpcErrors.internal({\n        message: `Error while running snap '${snapId}': ${cause.message}`,\n        data: {\n          cause: cause.serialize(),\n        },\n      });\n    }\n  }\n\n  /**\n   * Cancels all running evaluations of all snaps and clears all snap data.\n   * NOTE:** Should only be called in response to the `terminate` RPC command.\n   */\n  protected onTerminate() {\n    // `stop()` tears down snap endowments.\n    // Teardown will also be run for each snap as soon as there are\n    // no more running evaluations for that snap.\n    this.snapData.forEach((data) =>\n      data.runningEvaluations.forEach((evaluation) => evaluation.stop()),\n    );\n    this.snapData.clear();\n  }\n\n  private registerSnapExports(snapId: string, snapModule: any) {\n    const data = this.snapData.get(snapId);\n    // Somebody deleted the snap before we could register.\n    if (!data) {\n      return;\n    }\n\n    data.exports = SNAP_EXPORT_NAMES.reduce((acc, exportName) => {\n      const snapExport = snapModule.exports[exportName];\n      const { validator } = SNAP_EXPORTS[exportName];\n      if (validator(snapExport)) {\n        return { ...acc, [exportName]: snapExport };\n      }\n      return acc;\n    }, {});\n  }\n\n  /**\n   * Instantiates a snap API object (i.e. `globalThis.snap`).\n   *\n   * @param provider - A StreamProvider connected to MetaMask.\n   * @returns The snap provider object.\n   */\n  private createSnapGlobal(provider: StreamProvider): SnapsProvider {\n    const originalRequest = provider.request.bind(provider);\n\n    const request = async (args: RequestArguments) => {\n      const sanitizedArgs = sanitizeRequestArguments(args);\n      assertSnapOutboundRequest(sanitizedArgs);\n      return await withTeardown(\n        (async () => {\n          await this.#notify({\n            method: 'OutboundRequest',\n            params: { source: 'snap.request' },\n          });\n          try {\n            return await originalRequest(sanitizedArgs);\n          } finally {\n            await this.#notify({\n              method: 'OutboundResponse',\n              params: { source: 'snap.request' },\n            });\n          }\n        })(),\n        this as any,\n      );\n    };\n\n    // Proxy target is intentionally set to be an empty object, to ensure\n    // that access to the prototype chain is not possible.\n    const snapGlobalProxy = new Proxy(\n      {},\n      {\n        has(_target: object, prop: string | symbol) {\n          return typeof prop === 'string' && ['request'].includes(prop);\n        },\n        get(_target, prop: keyof StreamProvider) {\n          if (prop === 'request') {\n            return request;\n          }\n\n          return undefined;\n        },\n      },\n    ) as SnapsProvider;\n\n    return harden(snapGlobalProxy);\n  }\n\n  /**\n   * Instantiates an EIP-1193 Ethereum provider object (i.e. `globalThis.ethereum`).\n   *\n   * @param provider - A StreamProvider connected to MetaMask.\n   * @returns The EIP-1193 Ethereum provider object.\n   */\n  private createEIP1193Provider(provider: StreamProvider): StreamProvider {\n    const originalRequest = provider.request.bind(provider);\n\n    const request = async (args: RequestArguments) => {\n      const sanitizedArgs = sanitizeRequestArguments(args);\n      assertEthereumOutboundRequest(sanitizedArgs);\n      return await withTeardown(\n        (async () => {\n          await this.#notify({\n            method: 'OutboundRequest',\n            params: { source: 'ethereum.request' },\n          });\n          try {\n            return await originalRequest(sanitizedArgs);\n          } finally {\n            await this.#notify({\n              method: 'OutboundResponse',\n              params: { source: 'ethereum.request' },\n            });\n          }\n        })(),\n        this as any,\n      );\n    };\n\n    const streamProviderProxy = proxyStreamProvider(provider, request);\n\n    return harden(streamProviderProxy);\n  }\n\n  /**\n   * Removes the snap with the given name.\n   *\n   * @param snapId - The id of the snap to remove.\n   */\n  private removeSnap(snapId: string): void {\n    this.snapData.delete(snapId);\n  }\n\n  /**\n   * Calls the specified executor function in the context of the specified snap.\n   * Essentially, this means that the operation performed by the executor is\n   * counted as an evaluation of the specified snap. When the count of running\n   * evaluations of a snap reaches zero, its endowments are torn down.\n   *\n   * @param snapId - The id of the snap whose context to execute in.\n   * @param executor - The function that will be executed in the snap's context.\n   * @returns The executor's return value.\n   * @template Result - The return value of the executor.\n   */\n  private async executeInSnapContext<Result>(\n    snapId: string,\n    executor: () => Promise<Result> | Result,\n  ): Promise<Result> {\n    const data = this.snapData.get(snapId);\n    if (data === undefined) {\n      throw rpcErrors.internal(\n        `Tried to execute in context of unknown snap: \"${snapId}\".`,\n      );\n    }\n\n    let stop: () => void;\n    const stopPromise = new Promise<never>(\n      (_, reject) =>\n        (stop = () =>\n          reject(\n            // TODO(rekmarks): Specify / standardize error code for this case.\n            rpcErrors.internal(\n              `The snap \"${snapId}\" has been terminated during execution.`,\n            ),\n          )),\n    );\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const evaluationData = { stop: stop! };\n\n    try {\n      data.runningEvaluations.add(evaluationData);\n      // Notice that we have to await this executor.\n      // If we didn't, we would decrease the amount of running evaluations\n      // before the promise actually resolves\n      return await Promise.race([executor(), stopPromise]);\n    } catch (error) {\n      throw new WrappedSnapError(error);\n    } finally {\n      data.runningEvaluations.delete(evaluationData);\n\n      if (data.runningEvaluations.size === 0) {\n        this.lastTeardown += 1;\n        await data.idleTeardown();\n      }\n    }\n  }\n}\n"],"mappings":"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","names":[]}